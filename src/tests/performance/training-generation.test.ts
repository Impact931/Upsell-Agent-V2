import { describe, it, expect, beforeEach, vi } from 'vitest';
import { OpenAIService } from '@/lib/openai';

describe('Training Generation Performance Tests', () => {
  let openaiService: OpenAIService;

  beforeEach(() => {
    vi.clearAllMocks();
    openaiService = OpenAIService.getInstance();
  });

  const createMockContext = (productName: string, includeTypes: string[]) => ({
    product: {
      id: `product-${Date.now()}`,
      userId: 'perf-test-user',
      name: productName,
      description: `Performance test product: ${productName}`,
      price: 99.99,
      category: 'Skincare',
      ingredients: ['ingredient1', 'ingredient2', 'ingredient3'],
      benefits: ['benefit1', 'benefit2', 'benefit3'],
      targetAudience: 'Adult women',
      createdAt: new Date(),
      updatedAt: new Date(),
    },
    businessType: 'spa',
    targetAudience: 'Adult women seeking premium skincare',
    tone: 'professional',
    includeTypes: includeTypes as any,
  });

  it('should generate single training material within 30 seconds', async () => {
    // Mock OpenAI to simulate realistic response times
    const mockOpenAI = vi.mocked(require('openai').default);
    mockOpenAI.mockImplementation(() => ({
      chat: {
        completions: {
          create: vi.fn().mockImplementation(async () => {
            // Simulate API latency (2-5 seconds is typical)
            await new Promise(resolve => setTimeout(resolve, 2000));
            return {
              choices: [{
                message: {
                  content: `# Sales Script: Test Product

## Introduction
Welcome to our premium skincare consultation. Based on your skin analysis today, I'd love to introduce you to our Test Product.

## Product Benefits
This advanced formula contains three key ingredients that work synergistically to deliver visible results:
- Ingredient1: Provides deep hydration
- Ingredient2: Stimulates collagen production  
- Ingredient3: Offers antioxidant protection

## Value Proposition
At $99.99, this product offers professional-grade results equivalent to multiple spa treatments.

## Closing
Would you like to take advantage of our client-exclusive pricing today?

---
**Disclaimer**: This information is for general wellness purposes only and does not constitute medical advice.`
                }
              }]
            };
          })
        }
      }
    }));

    const context = createMockContext('Performance Test Serum', ['script']);

    const startTime = Date.now();
    const result = await openaiService.generateTrainingMaterial(context, 'script');
    const endTime = Date.now();

    const generationTime = (endTime - startTime) / 1000;

    expect(result).toBeDefined();
    expect(result.length).toBeGreaterThan(100); // Should have substantial content
    expect(generationTime).toBeLessThan(30); // Should complete within 30 seconds
    
    console.log(`Single material generation time: ${generationTime.toFixed(2)}s`);
  }, 35000);

  it('should generate all training materials within 5-minute target', async () => {
    const mockOpenAI = vi.mocked(require('openai').default);
    mockOpenAI.mockImplementation(() => ({
      chat: {
        completions: {
          create: vi.fn().mockImplementation(async () => {
            // Simulate varied API response times (1-4 seconds)
            const delay = Math.random() * 3000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
            
            return {
              choices: [{
                message: {
                  content: `Comprehensive training material content that would typically be generated by OpenAI. This includes detailed product information, sales techniques, customer objection handling, and frequently asked questions. The content is tailored for spa professionals and includes appropriate disclaimers for wellness products.`
                }
              }]
            };
          })
        }
      }
    }));

    const context = createMockContext(
      'Complete Performance Test Suite',
      ['script', 'guide', 'faq', 'objection-handling']
    );

    const startTime = Date.now();
    const results = await openaiService.generateAllTrainingMaterials(context);
    const endTime = Date.now();

    const totalTime = (endTime - startTime) / 1000;
    const averageTimePerMaterial = totalTime / results.length;

    expect(results).toHaveLength(4);
    expect(totalTime).toBeLessThan(300); // 5 minutes = 300 seconds
    expect(averageTimePerMaterial).toBeLessThan(75); // Average should be under 1.25 minutes
    
    console.log(`Total generation time: ${totalTime.toFixed(2)}s`);
    console.log(`Average time per material: ${averageTimePerMaterial.toFixed(2)}s`);
    
    // Verify quality - each material should have substantial content
    results.forEach((material, index) => {
      expect(material.content.length).toBeGreaterThan(200);
      expect(material.duration).toBeGreaterThan(0);
      console.log(`Material ${index + 1} (${material.type}): ${material.content.length} chars, ${material.duration}min`);
    });
  }, 320000);

  it('should handle concurrent training generation efficiently', async () => {
    const mockOpenAI = vi.mocked(require('openai').default);
    mockOpenAI.mockImplementation(() => ({
      chat: {
        completions: {
          create: vi.fn().mockImplementation(async () => {
            // Simulate API latency with some variability
            await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000));
            return {
              choices: [{
                message: {
                  content: 'Concurrent test training material content with sufficient length to be realistic.'
                }
              }]
            };
          })
        }
      }
    }));

    // Create multiple concurrent generation requests
    const contexts = Array.from({ length: 5 }, (_, i) => 
      createMockContext(`Concurrent Test Product ${i + 1}`, ['script'])
    );

    const startTime = Date.now();
    
    // Run generations concurrently
    const promises = contexts.map(context => 
      openaiService.generateTrainingMaterial(context, 'script')
    );
    
    const results = await Promise.all(promises);
    const endTime = Date.now();

    const totalTime = (endTime - startTime) / 1000;
    
    expect(results).toHaveLength(5);
    expect(totalTime).toBeLessThan(10); // Should be much faster than sequential (5 * 2.5s)
    
    // All results should be valid
    results.forEach(result => {
      expect(result).toBeDefined();
      expect(result.length).toBeGreaterThan(50);
    });
    
    console.log(`Concurrent generation time for 5 materials: ${totalTime.toFixed(2)}s`);
    console.log(`Average concurrent time per material: ${(totalTime / 5).toFixed(2)}s`);
  }, 15000);

  it('should maintain performance under load simulation', async () => {
    const mockOpenAI = vi.mocked(require('openai').default);
    let callCount = 0;
    
    mockOpenAI.mockImplementation(() => ({
      chat: {
        completions: {
          create: vi.fn().mockImplementation(async () => {
            callCount++;
            // Simulate increasing response time under load
            const baseDelay = 1000;
            const loadDelay = Math.min(callCount * 100, 2000); // Max 3s total
            await new Promise(resolve => setTimeout(resolve, baseDelay + loadDelay));
            
            return {
              choices: [{
                message: {
                  content: `Load test material #${callCount} with realistic content length for performance testing.`
                }
              }]
            };
          })
        }
      }
    }));

    const batchSize = 10;
    const contexts = Array.from({ length: batchSize }, (_, i) => 
      createMockContext(`Load Test Product ${i + 1}`, ['script'])
    );

    const startTime = Date.now();
    
    // Process in smaller batches to simulate real usage
    const batchResults = [];
    for (let i = 0; i < contexts.length; i += 3) {
      const batch = contexts.slice(i, i + 3);
      const batchPromises = batch.map(context => 
        openaiService.generateTrainingMaterial(context, 'script')
      );
      const results = await Promise.all(batchPromises);
      batchResults.push(...results);
      
      // Small delay between batches to simulate realistic usage
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    const endTime = Date.now();
    const totalTime = (endTime - startTime) / 1000;
    
    expect(batchResults).toHaveLength(batchSize);
    expect(totalTime).toBeLessThan(60); // Should complete within 1 minute
    
    // Verify degradation is acceptable (last requests shouldn't be more than 2x slower)
    const averageTime = totalTime / batchSize;
    expect(averageTime).toBeLessThan(6); // 6 seconds average is acceptable under load
    
    console.log(`Load test completed: ${batchSize} materials in ${totalTime.toFixed(2)}s`);
    console.log(`Average time per material under load: ${averageTime.toFixed(2)}s`);
    console.log(`API calls made: ${callCount}`);
  }, 70000);

  it('should validate memory usage during intensive operations', async () => {
    const mockOpenAI = vi.mocked(require('openai').default);
    mockOpenAI.mockImplementation(() => ({
      chat: {
        completions: {
          create: vi.fn().mockImplementation(async () => {
            await new Promise(resolve => setTimeout(resolve, 1000));
            // Return larger content to test memory usage
            return {
              choices: [{
                message: {
                  content: 'A'.repeat(10000) // 10KB content per response
                }
              }]
            };
          })
        }
      }
    }));

    const initialMemory = process.memoryUsage();
    
    // Generate multiple large training materials
    const contexts = Array.from({ length: 20 }, (_, i) => 
      createMockContext(`Memory Test Product ${i + 1}`, ['script'])
    );

    const promises = contexts.map(context => 
      openaiService.generateTrainingMaterial(context, 'script')
    );
    
    const results = await Promise.all(promises);
    
    const finalMemory = process.memoryUsage();
    const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;
    const memoryIncreaseMB = memoryIncrease / (1024 * 1024);
    
    expect(results).toHaveLength(20);
    expect(memoryIncreaseMB).toBeLessThan(100); // Should not use more than 100MB additional
    
    console.log(`Memory usage increase: ${memoryIncreaseMB.toFixed(2)}MB`);
    console.log(`Average memory per material: ${(memoryIncreaseMB / 20).toFixed(2)}MB`);
  }, 30000);
});